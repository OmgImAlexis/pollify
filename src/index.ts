import { EventEmitter } from 'events';

export interface PollifyOptions {
  /** The rate in milliseconds with which to execute pollFn. */
  rate?: number;
  /** The mode of the pollFn return type. */
  mode: 'promise' | 'callback' | 'return';
};

/** The function to be polled. The results of `pollFn()` will be emitted. */
export type PollFunction = ((...fnArgs: PollFunctionArgs) => any);

/** The arguments pollFn should be called with. */
export type PollFunctionArgs = any[];

/**
 * Produces an object that represents a stream of events generated by polling a provided function.
 */
export class Pollify extends EventEmitter {
  /** The function run every time this polls. */
  pollFn: PollFunction;
  /** Is this poll currently stopped? */
  stopped: boolean;
  /** Has this poll been run before? */
  firstRun: boolean;
  fnArgs: PollFunctionArgs;
  /** The rate in milliseconds with which to execute pollFn. */
  rate: number;
  /** The mode of the pollFn return type. */
  mode: string;

  constructor(options: PollifyOptions, pollFn: PollFunction, ...fnArgs: PollFunctionArgs) {
    super();

    this.rate = options.rate ?? 0;
    this.mode = options.mode;
    this.stopped = false;
    this.firstRun = true;
    this.pollFn = pollFn;
    this.fnArgs = fnArgs;

    this.poll();
  }

  _promise(startTime: number) {
    const req = this.pollFn(...this.fnArgs).then((data: any) => {
      this.emit('data', data, startTime);
    }).catch((e: unknown) => this.emit('error', e));

    // eslint-disable-next-line promise/catch-or-return
    req.then(() => this.rePoll(startTime));
  }

  _callback(startTime: number) {
    this.pollFn(...this.fnArgs, (e: any, ...data: any[]) => {
      if (e) {
        return this.emit('error', e);
      }

      this.emit('data', ...data, startTime);
      this.rePoll(startTime);
    });
  }

  _return(startTime: number) {
    try {
      const data = this.pollFn(...this.fnArgs);
      this.emit('data', data, startTime);
    } catch (e) {
      this.emit('error', e);
    }

    this.rePoll(startTime);
  }

  poll() {
    if (this.stopped) return;

    const startTime = Date.now();
    if (this.mode === 'promise') this._promise(startTime);
    if (this.mode === 'callback') this._callback(startTime);
    if (this.mode === 'return') this._return(startTime);
    this.firstRun = false;
  }

  rePoll(startTime: number) {
    const timeDiff = this.rate - (Date.now() - startTime);

    if (timeDiff > 0) {
      return setTimeout(() => {
        this.poll();
      }, timeDiff);
    }

    return setImmediate(this.poll);
  }

  /**
   * Will start the event stream. Polls are started by default on construction.
   */
  start() {
    if (!this.stopped) return;

    this.stopped = false;
    this.poll();
  }

  /**
   * Will stop the event stream.
   */
  stop() {
    this.stopped = true;
  }

  emit(event: string | symbol, ...args: any[]): boolean {
    if (this.firstRun) {
      return process.nextTick(() => super.emit(event, ...args)) as unknown as boolean;
    }

    return super.emit(event, ...args);
  }
};

export default function(options: PollifyOptions, pollFn: PollFunction, ...fnArgs: PollFunctionArgs) {
  return new Pollify(options, pollFn, ...fnArgs);
};